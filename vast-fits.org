#+TITLE: VAST Fits
#+PROPERTY: header-args :tangle yes

* Setup

#+BEGIN_SRC R :session *R-vast*
library(tidyverse)
## library(VAST)
## library(FishStatsUtils)
devtools::load_all("~/src/FishStatsUtils", helpers = FALSE, export_all = FALSE)
devtools::load_all("~/src/VAST", helpers = FALSE, export_all = FALSE)
devtools::load_all("~/src/spatq", helpers = FALSE)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session *R-vast*
## coordref <- read_csv("coordref.csv",
##                      col_types = cols(
##                        loc_idx = col_integer(),
##                        s1 = col_double(),
##                        s2 = col_double()))
## catch_df <- read_csv("repl_01/catch_01_pref.csv",
##                      col_types = cols(
##                        time = col_integer(),
##                        vessel_idx = col_integer(),
##                        loc_idx = col_integer(),
##                        coordinates = col_character(),
##                        effort = col_double(),
##                        catch_biomass = col_double())) %>%
##   left_join(coordref, by = "loc_idx") %>%
##   select(-coordinates, -loc_idx)
## write_csv(catch_df, "catch_sim.csv")
#+END_SRC

#+RESULTS:

** Import simulated data
Data are simulated by =FisherySim.jl= through the =SpatQSims.jl= Julia packages.
The R =spatq= package includes convenient mechanisms for importing these data
sets.

#+BEGIN_SRC R :session *R-vast*
catch_df <- read.csv("catch_sim.csv") %>%
  mutate(s1 = (s1 - 50) / 100,
         s2 = (s2 - 50) / 100)
#+END_SRC

#+RESULTS:

First create the extrapolation grid. Here keeping everything centered on the
equator/prime meridian intersection within a 1°×1° box to minimize issues with
Lon/Lat conversions.

#+BEGIN_SRC R :session *R-vast*
extrap_grid <- cross_df(list(Lon = (seq(0.5, 99.5, 1) - 50) / 100,
                             Lat = (seq(0.5, 99.5, 1) - 50) / 100)) %>%
  mutate(Area_km2 = 1) %>%
  as.matrix

vast_extrap <- make_extrapolation_info(Region = "user",
                                       zone = NA,
                                       strata.limits =
                                         data.frame(STRATA = "All_areas"),
                                       input_grid = extrap_grid)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session *R-vast*
vast_spat <- make_spatial_info(n_x = 404,
                               Lon_i = catch_df$s1,
                               Lat_i = catch_df$s2,
                               Extrapolation_List = vast_extrap,
                               Method = "Mesh",
                               fine_scale = TRUE,
                               Save_Results = FALSE,
                               refine = TRUE)
#+END_SRC

#+RESULTS:

This provides a usable mesh, albeit not one that matches the default in =spatq=.

#+RESULTS:

#+BEGIN_SRC R :session *R-vast*
vast_data <- make_data(b_i = catch_df$catch_biomass,
                       a_i = catch_df$effort,
                       ## c_iz needs to be zero-indexed, as
                       ## VAST/R/make_data.R:155 assigns `n_c = max(c_iz) + 1`
                       c_iz = matrix(rep_along(catch_df$catch_biomass, 0)),
                       t_iz = catch_df$time,
                       FieldConfig = c(Omega1 = 1, Epsilon1 = 0,
                                       Omega2 = 1, Epsilon2 = 0),
                       ObsModel_ez = c(PosDist = 1, Link = 1),
                       spatial_list = vast_spat,
                       Aniso = FALSE,
                       CheckForErrors = TRUE)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session *R-vast*
vast_model <- make_model(TmbData = vast_data,
                         Version = get_latest_version())
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session *R-vast*
vast_fit <- optim(vast_model$Obj$par, vast_model$Obj$fn, vast_model$Obj$gr,
                  method = "BFGS")
vast_sdr <- sdreport(vast_model$Obj)
#+END_SRC

#+RESULTS:

So VAST /is/ giving a PD hessian with the first replicate of the simulated data.
Not sure what the differences are, but both =logkappa= parameters are small(-3.5
ish), equivalent to correlation range of roughly 90. That's probably consistent
with the simulated data.

Of note is that the condition number of the fixed-effect covariance matrices is
fairly large - should expect to lose src_R[:session
*R-vast*]{log10(kappa(vast_sdr$cov.fixed))} {{{results(=8.48753029091291=)}}}
digits to numerical error.

#+BEGIN_SRC R :session *R-vast*
time_string <- format(Sys.time(), "%Y-%m-%dT%H:%M")
saveRDS(vast_sdr, paste0("vast_sdr_", time_string, ".RData"))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session *R-vast*
vast_model_v1 <- make_model(TmbData = vast_data,
                            Version = "v1_0_0")
#+END_SRC

#+RESULTS:


** [2020-04-21 Tue]
Ran this VAST fit again. For some reason, now gives non-PD Hessian. Fixed effect
parameters are different. In particular, all beta1 parameters are approximately
0.155 larger and beta2 are 0.023 higher. Is this an identifiability issue?

** [2020-04-22 Wed]
Ran it again, still non-PD Hessian. Starting from the fixed parameter values
that /did/ give a PD Hessian, a PD Hessian can be found again. So it (partially,
at least) comes down to nonlinear optimization issues. Of note is that the =mgc=
from ~sdreport~ is still ~4, which doesn't give me a lot of confidence that
we're in the right place. But maybe this is normal?

Eigendecomposition of =cov.fixed= gives a largest eigenvalue of 4.5e3, quickly
decreasing by multiple orders of magnitude. Process 1 parameters are 1e-5, while
process 2 are 1e-1, which probably (?) indicates that these are the problematic ones.

Looking at the correlation matrix (from =cov.fixed=), the beta parameters are
all /super/ correlated; there are two blocks where off-diagonal entries are
~0.9999. This definitely seems like a problem. Is this normal in VAST?
